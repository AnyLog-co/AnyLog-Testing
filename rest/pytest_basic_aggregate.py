import argparse 
import datetime 
import json 
import os 
import pytest
import requests
import yaml 

import read_config 

CONFIG_FILE = '$HOME/AnyLog-Network/tests/rest/configs/default_config.yaml' 
#CONFIG_FILE = '$HOME/AnyLog-Network/tests/rest/power_grid.meter_data.config.yaml' 

class TestBasicAggregates: 
   """
   For each aggregate (COUNT, MIN, MAX, AVG, SUM) check that the result of N nodes (alone) is equal to combined via REST
   """ 
   def setup_class(self): 
      """
      Setup class 
      :param:
         self.timestamp - for SQL oldest query date 
         self.config_info - based on CONFIG_FILE info for REST requets 
      """
      self.config_info = read_config.read_config(CONFIG_FILE)
      if not self.config_info: 
         exit(1) 

   def setup(self): 
      """
      setup method
      :param: 
         self.test_fail:bool - updated by test_keys or test_status to check config are valid for farther testing
      """
      self.test_fail = False 
   
   def teardown(self): 
      """
      Test if test_keys or test_status failed. If so exist (cannot continue) 
      """
      if self.test_fail is True: 
         exit(1) 

  
   def __execute_query(self, headers:dict)->dict: 
      """
      Execute query based on headers 
      :args: 
         headers:dict - header 
      :return: 
         results in the form of headers 
      """
      try: 
          return requests.get('http://%s' % self.config_info['REST'], headers=headers).json() 
      except Exception as e: 
         print(e) 
         return {} 

   def test_status(self): 
      """
      Test node is accessible
      :assert: 
         node is running 
      """
      headers = {'type': 'info', 'details': 'get status'} 
      results = self.__execute_query(headers)
      try: 
          assert 'running' in results['Status']
      except: 
         self.test_fail = True 
         assert False 

   def test_keys(self): 
      """
      Test self.config_info is valid
      :assert: 
         keys in self.config_info are as expected 
      """
      config_keys = ['REST', 'OPERATOR', 'DB', 'TABLE', 'TABLE COLUMNS', 'MIN DAYS BACK', 'MAX DAYS BACK']
      if list(self.config_info.keys()) != config_keys:
          self.test_fail = True 
      assert list(self.config_info.keys()) == config_keys 

   def test_count(self): 
      """
      Validate row count
      :query: 
         SELECT COUNT(*) FROM table_name
      :assert: 
         sum of row counts equals that generated by AnyLog 
      """
      query = 'SELECT COUNT(*) AS count FROM %s;'  % self.config_info['TABLE'] 
      headers =  {'type': 'sql', 'dbms': self.config_info['DB'], 'details': query}
      results = self.__execute_query(headers)

      count = 0  
     
      try:
         count = int(results['Query'][0]['count'])
      except: 
         assert False
     

      total_count = 0 
      for server in self.config_info['OPERATOR']: 
         header = headers
         header['servers'] = server

         results = self.__execute_query(headers)
         print(server, results) 
         try:
            total_count += int(results['Query'][0]['count'])
         except: 
            assert False

      assert count == total_count

   @pytest.mark.skip
   def test_count_col_name(self): 
      """
      Validate row count based on column name 
      :query: 
         SELECT COUNT(col_name) FROM table_name
      :assert: 
         sum of row counts equals that generated by AnyLog 
      """
      for col in self.config_info['TABLE COLUMNS']: 
         print(col) 
         query = 'SELECT COUNT(%s) AS count FROM %s;'  % (col, self.config_info['TABLE'])
         headers =  {'type': 'sql', 'dbms': self.config_info['DB'], 'details': query}
         results = self.__execute_query(headers)

         expected_count = 0  
         try:
            expected_count = int(results['Query'][0]['count'])
         except: 
            assert False
      
         actual_count = 0 
         for server in self.config_info['OPERATOR']: 
            header = headers
            header['servers'] = server

            results = self.__execute_query(header)
            try:
               actual_count += int(results['Query'][0]['count'])
            except: 
               assert False

         assert expected_count == actual_count

   @pytest.mark.skip
   def test_count_col_name2(self): 
      """
      Validate row count based on column name
      :query: 
         SELECT COUNT(col_name) FROM table_name
      :assert: 
         assert all results to be consistent - equals to COUNT(*) 
      """
      query = 'SELECT COUNT(*) AS count FROM %s' % self.config_info['TABLE']
      headers = {'type': 'sql', 'dbms': self.config_info['DB'], 'details': query}
      results = self.__execute_query(headers) 
      expect_count = results['Query'][0]['count'] 

      for col in self.config_info['TABLE COLUMNS']: 
         query = 'SELECT COUNT(%s) AS count FROM %s;'  % (col, self.config_info['TABLE'])
         headers =  {'type': 'sql', 'dbms': self.config_info['DB'], 'details': query}
         results = self.__execute_query(headers)
         assert expect_count == results['Query'][0]['count'] 

   @pytest.mark.skip
   def test_count_col_name(self): 
      """
      Validate row count based on column name 
      :query: 
         SELECT COUNT(col_name) FROM table_name
      :assert: 
         sum of row counts equals that generated by AnyLog 
      """
      for col in self.config_info['TABLE COLUMNS']: 
         query = 'SELECT COUNT(%s) AS count FROM %s;'  % (col, self.config_info['TABLE'])
         headers =  {'type': 'sql', 'dbms': self.config_info['DB'], 'details': query}
         results = self.__execute_query(headers)

         count = 0  
         try:
            count = int(results['Query'][0]['count'])
         except: 
            assert False
      
         total_count = 0 
         for server in self.config_info['OPERATOR']: 
            header = headers
            header['servers'] = server

            results = self.__execute_query(header)
            try:
               total_count += int(results['Query'][0]['count'])
            except: 
               assert False

         assert count == total_count


   def test_count_distinct(self): 
      """
      Test COUNT(DSTINCT)) for each column type 
      :query: 
         SELECT COUNT(DISTINCT(col_name)) FROM table_name 
      :assert:
         count distinct 
      """
      for col in self.config_info['TABLE COLUMNS']:
         query = 'SELECT COUNT(DISTINCT(%s)) AS %s FROM %s' % (col, col, self.config_info['TABLE'])
         headers =  {'type': 'sql', 'dbms': self.config_info['DB'], 'details': query}
         results = self.__execute_query(headers)
         count_distinct = results['Query'][0][col] 
         print(count_distinct)

         distinct = [] 
         for server in self.config_info['OPERATOR']:
            header = headers 
            header['details'] = "SELECT DISTINCT(%s) AS %s FROM %s;" % (col, col, self.config_info['TABLE'])
            header['servers'] = server 
            tmp_results = self.__execute_query(header) 
            print(server,  tmp_results) 
            for result in tmp_results['Query']:
               if result[col] not in distinct: 
                  distinct.append(result[col]) 
         assert int(count_distinct) == len(distinct) 

   def test_distinct(self): 
      """
      Check distinct values for each column 
      :query: 
         SELECT DISTINCT(col_name) FROM table_name
      :assert: 
         distinct rows are returned 
      """
      for col in self.config_info['TABLE COLUMNS']:
         print(col) 
         distinct_results = [] 
         query = 'SELECT DISTINCT(%s) as %s FROM %s' % (col, col, self.config_info['TABLE'])
         headers =  {'type': 'sql', 'dbms': self.config_info['DB'], 'details': query}
         results = self.__execute_query(headers)
         for result in results['Query']: 
            distinct_results.append(result[col])
         
         distinct = [] 
         for server in self.config_info['OPERATOR']: 
            header = headers
            header['servers'] = server 

            results = self.__execute_query(header) 
            for result in results['Query']:
                if result[col] not in distinct:
                   distinct.append(result[col])
                   
         print(len(distinct_results), len(distinct))
         assert set(distinct_results) == set(distinct) 

   def test_min(self): 
      """
      Validate min value for timestmap, int, float and double data-type 
      :query: 
         SELECT MIN(col_name) FROM table_name
      :assert: 
         validate min value 
      """
      for column in self.config_info['TABLE COLUMNS']:
         if self.config_info['TABLE COLUMNS'][column].lower() != 'string': 
            col = column
            distinct_results = [] 
            query = 'SELECT MIN(%s) as min_%s FROM %s' % (col, col, self.config_info['TABLE'])
            headers =  {'type': 'sql', 'dbms': self.config_info['DB'], 'details': query}
            results = self.__execute_query(headers)
            try: 
               absoultue_min = results['Query'][0]['min_%s' % col]
            except:
               assert False 

            min_values = []  
            for server in self.config_info['OPERATOR']: 
               header = headers  
               header['servers'] = server 
               results = self.__execute_query(headers)
               try: 
                  min_values.append(results['Query'][0]['min_%s' % col])
               except: 
                  assert False 
               
            assert min(min_values) == absoultue_min

   def test_max(self): 
      """
      Validate max value for timestmap, int, float and double data-type 
      :query: 
         SELECT MAX(col_name) FROM table_name
      :assert: 
         validate max value 
      """
      for column in self.config_info['TABLE COLUMNS']:
         if self.config_info['TABLE COLUMNS'][column].lower() != 'string': 
            col = column
            distinct_results = [] 
            query = 'SELECT MAX(%s) as max_%s FROM %s' % (col, col, self.config_info['TABLE'])
            headers =  {'type': 'sql', 'dbms': self.config_info['DB'], 'details': query}
            results = self.__execute_query(headers)
            try: 
               absoultue_max = results['Query'][0]['max_%s' % col]
            except:
               assert False 

            max_values = []  
            for server in self.config_info['OPERATOR']: 
               header = headers  
               header['servers'] = server 
               results = self.__execute_query(headers)
               try: 
                  max_values.append(results['Query'][0]['max_%s' % col])
               except: 
                  assert False 
               
            assert max(max_values) == absoultue_max


   def test_avg(self): 
      """
      Validate avg value for timestmap, int, float and double data-type 
      :query: 
         SELECT AVG(col_name) FROM table_name
      :assert: 
         validate AVG value 
      """
      for col in self.config_info['TABLE COLUMNS']:
         if self.config_info['TABLE COLUMNS'][col].lower() == 'numeric': 
            query = 'SELECT AVG(%s) as avg_%s FROM %s' % (col, col, self.config_info['TABLE'])
            headers =  {'type': 'sql', 'dbms': self.config_info['DB'], 'details': query}
            results = self.__execute_query(headers)
            try: 
               absoultue_avg = results['Query'][0]['avg_%s' % col]
            except:
               assert False 

            avg_values = {'sum': [], 'count': []} 
            for server in self.config_info['OPERATOR']: 
               header = headers  
               header['servers'] = server 
               header['details'] = 'SELECT SUM(%s) AS sum_%s, COUNT(%s) AS count_%s FROM  %s' %  (col, col, col, col, self.config_info['TABLE'])  
               results = self.__execute_query(header)
               try: 
                  avg_values['sum'].append(float(results['Query'][0]['sum_%s' %  col]))
                  avg_values['count'].append(int(results['Query'][0]['count_%s' % col])) 
               except: 
                  assert False 
            avg_value = float(sum(avg_values['sum']) / sum(avg_values['count']))
            assert round(float(avg_value), 2) == round(float(absoultue_avg), 2)


   def test_sum(self):
      """
      Validate sum value for timestmap, int, float and double data-type 
      :query: 
         SELECT SUM(col_name) FROM table_name
      :assert: 
         validate sum value 
      """
      for col in self.config_info['TABLE COLUMNS']:
         if self.config_info['TABLE COLUMNS'][col].lower() == 'numeric':
            print(col) 
            query = 'SELECT SUM(%s) as sum_%s FROM %s' % (col, col, self.config_info['TABLE'])
            headers =  {'type': 'sql', 'dbms': self.config_info['DB'], 'details': query}
            results = self.__execute_query(headers)
            try: 
               expected_total = int(results['Query'][0]['sum_%s' % col]) 
            except: 
               expected_total = float(results['Query'][0]['sum_%s' % col]) 
            else: 
               assert False 
               
            actual_total = []  
            for server in self.config_info['OPERATOR']:
                header = headers
                header['servers'] = server
                results = self.__execute_query(header)
                print(server, results)
                try: 
                   actual_total.append(int(results['Query'][0]['sum_%s' % col]))
                except: 
                   actual_total.append(float(results['Query'][0]['sum_%s' % col]))
                else: 
                   pass
            
            print(actual_total, expected_total) 
            assert actual_total == expected_total 
